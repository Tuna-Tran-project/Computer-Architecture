# Test program for RISC-V instructions in a 5-stage pipeline
# Starting address: 0x00000000
# Store before load, test rd after 5 cycles, use rd from previous instruction
# Address      Instruction                       Comment
0x00000000:  lui x1, 0x2                         # x1 = 0x00002000 (data memory base)
0x00000004:  addi x2, x0, 8                      # x2 = 8
0x00000008:  addi x3, x0, 10                     # x3 = 10
0x0000000C:  addi x4, x0, 255                    # x4 = 255
0x00000010:  addi x5, x0, -1                     # x5 = 0xFFFFFFFF
0x00000014:  addi x6, x0, 127                    # x6 = 127
0x00000018:  addi x7, x0, -128                   # x7 = 0xFFFFFF80
0x0000001C:  addi x8, x0, 2047                   # x8 = 2047
0x00000020:  addi x9, x0, -2048                  # x9 = 0xFFFFF800

0x00000024:  sw x2, 0(x1)                        # Mem[0x2000] = 8
0x00000028:  sh x3, 4(x1)                        # Mem[0x2004] = 10
0x0000002C:  sb x4, 8(x1)                        # Mem[0x2008] = 0xFF

0x00000030:  addi x21, x1, 2044                  # x21 = 0x2000 + 2044 = 0x27FC
0x00000034:  sw x5, 0(x21)                       # Mem[0x27FC] = 0xFFFFFFFF

0x00000038:  addi x22, x1, 256                   # x22 = 0x2000 + 256 = 0x2100
0x0000003C:  sw x6, 0(x22)                       # Mem[0x2100] = 127

0x00000040:  addi x23, x1, 260                   # x23 = 0x2000 + 260 = 0x2104
0x00000044:  sw x7, 0(x23)                       # Mem[0x2104] = 0xFFFFFF80

0x00000048:  addi x24, x1, 264                   # x24 = 0x2000 + 264 = 0x2108
0x0000004C:  sw x8, 0(x24)                       # Mem[0x2108] = 2047

0x00000050:  addi x25, x1, 268                   # x25 = 0x2000 + 268 = 0x210C
0x00000054:  sw x9, 0(x25)                       # Mem[0x210C] = 0xFFFFF800

0x00000058:  lw x10, 0(x1)                       # x10 = 8
0x0000005C:  lh x11, 4(x1)                       # x11 = 10
0x00000060:  lhu x12, 4(x1)                      # x12 = 10
0x00000064:  lb x13, 8(x1)                       # x13 = -1 (0xFFFFFFFF) //trong code thì cần fix lại lsu để chạy đúng là dc
0x00000068:  lbu x14, 8(x1)                      # x14 = 255
0x0000006C:  lw x15, 0(x21)                      # x15 = 0xFFFFFFFF
0x00000070:  lw x16, 0(x22)                      # x16 = 127
0x00000074:  lw x17, 0(x23)                      # x17 = 0xFFFFFF80
0x00000078:  lw x18, 0(x24)                      # x18 = 2047
0x0000007C:  lw x19, 0(x25)                      # x19 = 0xFFFFF800

# Test upper bound of data memory (0x3FFC)
0x00000080:  lui x26, 0x3                        # x26 = 0x3000
0x00000084:  addi x26, x26, 10                   # x26 = 0x300A
0x00000088:  sw x3, 0(x26)                       # Mem[0x300A] = 10
0x0000008C:  lw x21, 0(x26)                      # x21 = 10

# IO addresses (use base + offset, legal immediates)
0x00000090:  lui x27, 0x7000 >> 12               # x27 = 0x70000 (Red LEDs base)
0x00000094:  sw x6, 0(x27)                       # Red LED = 127

0x00000098:  lui x28, 0x7010 	                 # x28 = 0x70100 (Green LEDs base)
0x0000009C:  sw x7, 0(x28)                       # Green LED = -128

0x000000A0:  lui x29, 0x7020 	                 # x29 = 0x70200 (Seven-segment LEDs base)
0x000000A4:  sw x8, 0(x29)                       # Seven-segment LED = 2047

0x000000A8:  lui x30, 0x7030 	                 # x30 = 0x70300 (LCD control base)
0x000000AC:  sw x9, 0(x30)                       # LCD Control = -2048

0x000000B0:  lui x31, 0x7800                     # x31 = 0x78000 (Switches base)
0x000000B4:  lw x5, 0(x31)                       # Read switches

0x000000B8:  lui x6, 0x7810                      # x6 = 0x78100 (Buttons base)
0x000000BC:  lw x7, 0(x6)                        # Read buttons

# ALU operations
0x000000C0:  add x8, x10, x11                    # x8 = x10 + x11
0x000000C4:  sub x9, x10, x11                    # x9 = x10 - x11
0x000000C8:  and x10, x10, x11                   # x10 = x10 & x11
0x000000CC:  or x11, x10, x11                    # x11 = x10 | x11
0x000000D0:  xor x12, x10, x11                   # x12 = x10 ^ x11
0x000000D4:  sll x13, x10, x11                   # x13 = x10 << (x11 & 0x1F) = 0x2000
0x000000D8:  srl x14, x10, x11                   # x14 = x10 >> (x11 & 0x1F) = 0x0
0x000000DC:  sra x15, x10, x11                   # x15 = x10 >>> (x11 & 0x1F)= 0x0
0x000000E0:  slt x16, x10, x11                   # x16 = (x10 < x11) ? 1 : 0
0x000000E4:  sltu x17, x10, x11                  # x17 = (x10 < x11 unsigned) ? 1 : 0

# Immediate ALU
0x000000E8:  addi x18, x10, 1                    # x18 = x10 + 1
0x000000EC:  andi x19, x10, 0x7FF                # x19 = x10 & 0x7FF
0x000000F0:  ori x20, x10, 0x7FF                 # x20 = x10 | 0x7FF
0x000000F4:  xori x21, x10, 0x7FF                # x21 = x10 ^ 0x7FF
0x000000F8:  slti x22, x10, 127                  # x22 = (x10 < 127) ? 1 : 0
0x000000FC:  sltiu x23, x10, 127                 # x23 = (x10 < 127 unsigned) ? 1 : 0
0x00000100:  slli x24, x10, 4                    # x24 = x10 << 4
0x00000104:  srli x25, x10, 4                    # x25 = x10 >> 4
0x00000108:  srai x26, x10, 4                    # x26 = x10 >>> 4

# Branch and jump (labels use PC-relative offsets)
0x0000010C:  beq x10, x11, label_beq             # Branch if x10 == x11(no branch)
0x00000110:  bne x10, x11, label_bne             # Branch if x10 != x11(branch to 0x0x00000134)
0x00000114:  blt x10, x11, label_blt             # Branch if x10 < x11
0x00000118:  bge x10, x11, label_bge             # Branch if x10 >= x11
0x0000011C:  bltu x10, x11, label_bltu           # Branch if x10 < x11 (unsigned)
0x00000120:  bgeu x10, x11, label_bgeu           # Branch if x10 >= x11 (unsigned)
0x00000124:  nop                                 # No operation

0x00000128:  jal x5, label_jal                   # Jump to label_jal, x5 = return addr
0x0000012C:  addi x6, x0, 42                     # Should be skipped if jal taken
0x00000130:  jalr x7, 0(x5)                      # Jump to x5, x7 = return addr

# Unique instructions at each label
label_beq:   addi x1, x0, 101    # Beq taken: x1 = 101
label_bne:   addi x2, x0, 102    # Bne taken: x2 = 102
label_blt:   addi x3, x0, 103    # Blt taken: x3 = 103
label_bge:   addi x4, x0, 104    # Bge taken: x4 = 104
label_bltu:  addi x5, x0, 105    # Bltu taken: x5 = 105
label_bgeu:  addi x6, x0, 106    # Bgeu taken: x6 = 106
label_jal:   addi x7, x0, 107    # Jal taken: x7 = 107

0x00000150:  lui x8, 0x12345                     # x8 = 0x12345000
0x00000154:  auipc x9, 0x12345                   # x9 = PC + 0x12345000

0x00000158:  addi x0, x0, 1234                   # x0 always zero
0x0000015C:  sw x0, 0(x1)                        # Mem[0x2000] = 0
0x00000160:  lw x24, 0(x1)                       # x24 = 0

0x00000164:  jal x0, 0x00000164                  # Infinite loop

/////////////////////////////////TEST BR JAL JALR//////////////////////////////
 # Address      Instruction                         Comment
0x00000000:   lui   x1, 0x0                        # x1 = 0
0x00000004:   addi  x2, x0, 5                      # x2 = 5
0x00000008:   addi  x3, x0, 5                      # x3 = 5
0x0000000C:   addi  x4, x0, 0                      # x4 = 0
0x00000010:   addi  x5, x0, 1                      # x5 = 1

0x00000014:   beq   x2, x3, 0x0000001C             # Branch if x2==x3 (taken)
0x00000018:   addi  x6, x0, 0                      # Should be skipped if branch taken
0x0000001C:   addi  x6, x0, 101                    # x6 = 101 (BEQ taken)

0x00000020:   beq   x2, x4, 0x00000028             # Branch if x2==x4 (not taken)
0x00000024:   addi  x7, x0, 102                    # x7 = 102 (BEQ not taken)
0x00000028:   addi  x7, x0, 103                    # Will be overwritten if branch taken

0x0000002C:   bne   x2, x4, 0x00000034             # Branch if x2!=x4 (taken)
0x00000030:   addi  x8, x0, 0                      # Should be skipped if branch taken
0x00000034:   addi  x8, x0, 104                    # x8 = 104 (BNE taken)

0x00000038:   bne   x2, x3, 0x00000040             # Branch if x2!=x3 (not taken)
0x0000003C:   addi  x9, x0, 105                    # x9 = 105 (BNE not taken)
0x00000040:   addi  x9, x0, 106                    # Will be overwritten if branch taken

0x00000044:   blt   x4, x2, 0x0000004C             # Branch if x4<x2 (taken)
0x00000048:   addi  x10, x0, 0                     # Should be skipped if branch taken
0x0000004C:   addi  x10, x0, 107                   # x10 = 107 (BLT taken)

0x00000050:   blt   x2, x4, 0x00000058             # Branch if x2<x4 (not taken)
0x00000054:   addi  x11, x0, 108                   # x11 = 108 (BLT not taken)
0x00000058:   addi  x11, x0, 109                   # Will be overwritten if branch taken

0x0000005C:   bge   x2, x3, 0x00000064             # Branch if x2>=x3 (taken)
0x00000060:   addi  x12, x0, 0                     # Should be skipped if branch taken
0x00000064:   addi  x12, x0, 110                   # x12 = 110 (BGE taken)

0x00000068:   bge   x4, x2, 0x00000070             # Branch if x4>=x2 (not taken)
0x0000006C:   addi  x13, x0, 111                   # x13 = 111 (BGE not taken)
0x00000070:   addi  x13, x0, 112                   # Will be overwritten if branch taken

0x00000074:   bltu  x4, x2, 0x0000007C             # Branch if x4<x2 unsigned (taken)
0x00000078:   addi  x14, x0, 0                     # Should be skipped if branch taken
0x0000007C:   addi  x14, x0, 113                   # x14 = 113 (BLTU taken)

0x00000080:   bltu  x2, x4, 0x00000088             # Branch if x2<x4 unsigned (not taken)
0x00000084:   addi  x15, x0, 114                   # x15 = 114 (BLTU not taken)
0x00000088:   addi  x15, x0, 115                   # Will be overwritten if branch taken

0x0000008C:   bgeu  x2, x3, 0x00000094            # Branch if x2>=x3 unsigned (taken)
0x00000090:   addi  x16, x0, 0                     # Should be skipped if branch taken
0x00000094:   addi  x16, x0, 116                   # x16 = 116 (BGEU taken)

0x00000098:   bgeu  x4, x2, 0x000000A0            # Branch if x4>=x2 unsigned (not taken)
0x0000009C:   addi  x17, x0, 117                   # x17 = 117 (BGEU not taken)
0x000000A0:   addi  x17, x0, 118                   # Will be overwritten if branch taken

0x000000A4:   jal   x18, 0x000000AC                # Jump to jal_label
0x000000A8:   addi  x18, x0, 0                     # Should be skipped if JAL taken
0x000000AC:   addi  x19, x0, 119                   # x19 = 119 (JAL target)

0x000000B0:   lui   x20, %hi(0x000000C0)           # Load upper address of jalr_label
0x000000B4:   addi  x20, x20, %lo(0x000000C0)      # Add lower address bits
0x000000B8:   jalr  x21, 0(x20)                    # Jump to address in x20
0x000000BC:   addi  x21, x0, 0                     # Should be skipped if JALR taken
0x000000C0:   addi  x22, x0, 120                   # x22 = 120 (JALR target)

0x000000C4:   jal   x0, 0                          # Infinite loop